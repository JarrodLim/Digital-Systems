`timescale 1ns / 0.001ps
//lets build a 10hz counter to track 10ms, we can put each 10ms into the LEDs for visualization
//the second 500hz signal is used to quickly update the 7segment display, i.e. the board
//lets include additional buttons, Start, Stop and Reset
module stopwatch(
    input clk, //100MHz clock, this comes from the board
    input btnU, //start
    input btnD, //stop
    input btnC, //rest
    output [15:0]led, //for mili second counter
    //output [15:14]led, //to show the counters state
    output [6:0]seg, //to control the 7-segment display
    output [3:0]an, //to control 4 of the 7-segment displays
    output dp //to control the decimal point on the 7 segment display array
    );
    
//Since logic low >> logic high we do the following
wire Start; assign Start = ~btnU;
wire Stop; assign Stop = ~btnD;
wire Reset; assign Reset = ~btnC;

reg clk_1_hz;
reg clk_10_hz; 
reg clk_500_hz;
reg [8:0]clk_1_counter;
reg [5:0]clk_10_counter; //500/(10*2) = 25, 5 bits required
reg [16:0]clk_500_counter; 

//lets store the counter state to see what the counters should do
reg state = 0;//0 is stopped, 1 is start, 2 is reset
assign led[15:14] = 0;
always @(*)
    begin
     if(Start == 0)begin
        state = 1;
        end
     else if(Stop == 0)begin
        state = 0;
        end //stop count at current position
     else if(Reset == 0)begin
        state = 2;
        end //reset and continue running
    end
    assign led[15:14] = state;

//500hz clock
always@(posedge clk, posedge Start)begin
    if(!Reset)begin              //Non-Sync Reset
        clk_500_hz <= 1'b0;    //Set 500hz clock as '0' to avoid any uncertain status;        
        clk_500_counter <= 17'd0; //Clear counter
    end
    else begin
        if(clk_500_counter == 17'd100_000-1'b1)begin   //When counter reach 100_000
            clk_500_hz <= ~clk_500_hz;        //Toggle 500Hz CLk reg;
            clk_500_counter <= 17'd0;             //Clear counter
        end
        else if(state == 1) //only count if start
            clk_500_counter <= clk_500_counter +1'b1; //Counter
    end
end

//10hz clock
always@(posedge clk_500_hz, state == 1)begin
    if(!Reset)begin
        clk_10_hz <= 1'b0;
        clk_10_counter <= 6'd0;
    end
    else begin
        if(clk_10_counter == 6'd25-1'b1)begin //counting to 25 only, no need to 250
            clk_10_hz <= ~clk_10_hz; //because its 10hz
            clk_10_counter <= 6'd0;
        end
        else if(state == 1)//only count while it is started
            clk_10_counter <= clk_10_counter +1'b1;
    end
end

//1hz clock
always@(posedge clk_500_hz, state == 1)begin
    if(!Reset)begin
        clk_1_hz <= 1'b0;
        clk_1_counter <= 8'd0;
    end
    else begin
        if(clk_1_counter == 8'd250-1'b1)begin //counting to 25 only, no need to 250
            clk_1_hz <= ~clk_1_hz; //because its 10hz
            clk_1_counter <= 8'd0;
        end
        else if(state == 1)//only count while it is started
            clk_1_counter <= clk_1_counter +1'b1;
    end
end
//driving miliseconds using LEDs
reg [3:0]miliseconds = 0;
reg [3:0]seconds = 0;
reg [3:0]minutes = 0;
reg [9:0]led_state = 0;//{0,0,0,0,0,0,0,0,0,0};
always @(posedge clk_500_hz)begin
    if(state == 2 || miliseconds == 10)
        begin
        miliseconds = 0;
        seconds <= seconds + 1;
        led_state = 0;
        end;
    if(seconds == 60)
        begin
        seconds = 0;
        minutes <= minutes + 1;
        end
    case(miliseconds) //this is not running properly
        4'h0:led_state[0] = 1;
        4'h1:led_state[1] = 1;
        4'h2:led_state[2] = 1;
        4'h3:led_state[3] = 1;
        4'h4:led_state[4] = 1;
        4'h5:led_state[5] = 1;
        4'h6:led_state[6] = 1;
        4'h7:led_state[7] = 1;
        4'h8:led_state[8] = 1;
        4'h9:led_state[9] = 1;
    endcase
    miliseconds <= miliseconds + 1;
end

assign led[0] = led_state[0];
assign led[1] = led_state[1];
assign led[2] = led_state[2];
assign led[3] = led_state[3];
assign led[4] = led_state[4];
assign led[5] = led_state[5];
assign led[6] = led_state[6];
assign led[7] = led_state[7];
assign led[8] = led_state[8];
assign led[9] = led_state[9];


//driving anode aka selecting which 7 segment to use
reg [3:0]anodes;
assign an = ~anodes;
always @(negedge Start,posedge clk_500_hz)begin
    if(!Reset)begin
        anodes <= 4'b0000;    //When system reset, empty all display;
    end
    else begin
        case(anodes)                  
        4'b0001: anodes <= 4'b0010;   //DISPLAY ON DIG3
        4'b0010: anodes <= 4'b0100;   //DISPLAY ON DIG2
        4'b0100: anodes <= 4'b1000;   //DISPLAY ON DIG1
        default: anodes <= 4'b0001;   //DISPLAY ON DIG4
        endcase
    end
end
//When DIG4 on, BCD Number Display at this moment is bcd_num[3:0];  (i.e Stop Watch - Second Unit)
//When DIG3 on, BCD Number Display at this moment is bcd_num[7:4];  (i.e Stop Watch - Second Decade)
//When DIG2 on, BCD Number Display at this moment is bcd_num[11:8]; (i.e Stop Watch - Minute Unit)
//When DIG1 on, BCD Number Display at this moment is bcd_num[15:12];(i.e Stop Watch - Minute Decade)
reg [3:0]cur_num_r; 
wire [15:0]bcd_num;
always @(anodes,bcd_num)begin
    case(anodes)
        4'b0001: cur_num_r <= bcd_num[3:0];
        4'b0010: cur_num_r <= bcd_num[7:4];
        4'b0100: cur_num_r <= bcd_num[11:8];
        4'b1000: cur_num_r <= bcd_num[15:12];
        default: cur_num_r <= 4'b0;
    endcase    
end

//Decode BCD NUM into corrosponding 7Segment Code;
reg [7:0]segment_r; assign dp = segment_r[7];
always @(cur_num_r) begin
    case(cur_num_r)
        4'h0:segment_r <= 8'hc0;    //NUM "0"
        4'h1:segment_r <= 8'hf9;    //NUM "1"
        4'h2:segment_r <= 8'ha4;    //NUM "2"
        4'h3:segment_r <= 8'hb0;    //NUM "3"
        4'h4:segment_r <= 8'h99;    //NUM "4"
        4'h5:segment_r <= 8'h92;    //NUM "5"
        4'h6:segment_r <= 8'h82;    //NUM "6"
        4'h7:segment_r <= 8'hF8;    //NUM "7"
        4'h8:segment_r <= 8'h80;    //NUM "8"
        4'h9:segment_r <= 8'h90;    //NUM "9"
        default: segment_r <= 8'hff;
        // 4'ha:segment_r <= 8'h88;    //NUM "A" - HEX NUMBER DISPLAY
        // 4'hb:segment_r <= 8'h83;    //NUM "b"
        // 4'hc:segment_r <= 8'hc6;    //NUM "C"
        // 4'hd:segment_r <= 8'ha1;    //NUM "D"
        // 4'he:segment_r <= 8'h86;    //NUM "E"
        // 4'hf:segment_r <= 8'h8e;    //NUM "F"
    endcase
end

// Timer Section is composed with 4 BCD Number counter(Minute Decade,Minute Unit, Second Decade, Minute Unit);
reg [3:0] sec_unit_bcd_r,sec_deca_bcd_r,min_unit_bcd_r,min_deca_bcd_r; //Register - (Minute Decade,Minute Unit, Second Decade, Second Unit);
reg sec_unit_cout,sec_deca_cout,min_unit_cout; //Carry Out Signal, When 4 BCD Number counter reach upper limit, it will generate a cout signal;

//Counter           Upper Limit
//Minute Decade     5
//Minute Unit       9
//Second Decade     5
//Second Unit       9

always @(posedge clk_1_hz or negedge Start)begin
    if(!Reset)begin
        sec_unit_bcd_r <= 4'd0; //Clear BCD Number Counter;
        sec_unit_cout <= 1'b0;  //Clear Cout Signal;
    end
    else begin
        if(sec_unit_bcd_r == 4'h9)begin
            sec_unit_cout <= 1'b1;  //Cout generate a posedge;
            sec_unit_bcd_r <= 4'd0; //Clear BCD Number Counter;
        end
        else begin
            sec_unit_cout <= 1'b0;                      //Clear Cout Signal;
            sec_unit_bcd_r <= sec_unit_bcd_r + 1'b1; // BCD Number Counter increase by '1';
        end
    end
end

always @(posedge sec_unit_cout or negedge Start)begin
    if(!Reset)begin
        sec_deca_bcd_r <= 4'd0;
        sec_deca_cout <= 1'b0;
    end
    else begin
        if(sec_deca_bcd_r == 4'h5)begin
            sec_deca_cout <= 1'b1;
            sec_deca_bcd_r <= 4'd0;
        end
        else begin
            sec_deca_cout <= 1'b0;
            sec_deca_bcd_r <= sec_deca_bcd_r + 1'b1;
        end
    end
end

always @(posedge sec_deca_cout or negedge Start)begin
    if(!Reset)begin
        min_unit_bcd_r <= 4'd0;
        min_unit_cout <= 1'b0;
    end
    else begin
        if(min_unit_bcd_r == 4'h9)begin
            min_unit_cout <= 1'b1;
            min_unit_bcd_r <= 4'd0;
        end
        else begin
            min_unit_cout <= 1'b0;
            min_unit_bcd_r <= min_unit_bcd_r + 1'b1;
        end
    end
end

always @(posedge min_unit_cout or negedge Start)begin
    if(!Reset)begin
        min_deca_bcd_r <= 4'd0;
    end
    else begin
        if(min_deca_bcd_r == 4'h5)begin
            min_deca_bcd_r <= 4'd0;
        end
        else begin
            min_deca_bcd_r <= min_deca_bcd_r + 1'b1;
        end
    end
end

//When DIG4 on, BCD Number Display at this moment is bcd_num[3:0];  (i.e Stop Watch - Second Unit)
//When DIG3 on, BCD Number Display at this moment is bcd_num[7:4];  (i.e Stop Watch - Second Decade)
//When DIG2 on, BCD Number Display at this moment is bcd_num[11:8]; (i.e Stop Watch - Minute Unit)
//When DIG1 on, BCD Number Display at this moment is bcd_num[15:12];(i.e Stop Watch - Minute Decade)
assign  bcd_num[15:12]  = min_deca_bcd_r;
assign  bcd_num[11:8]   = min_unit_bcd_r;
assign  bcd_num[7:4]    = sec_deca_bcd_r;
assign  bcd_num[3:0]    = sec_unit_bcd_r;

endmodule
